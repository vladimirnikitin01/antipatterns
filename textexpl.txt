Архитектура игры, связанная с созданием отдельных юнитов (и не только):

1) Основной класс в игре - класс Game, в котором находится стек
существующих игровых состояний, представляемых интерфейсом State.

Персонаж: класс Player
2) Нас интересует класс GameState, который управляет игровым процессом.
Непосредственно в нём создаётся игровой персонаж (настройки загружаются
из конфигурационного файла, возможно в будущем появится выбор персонажем
игрового класса, но от этого зависит только набор характеристик и
способностей персонажа).

Player является представителем интерфейса
Creature, который, в свою очередь, хранит в себе различные компоненты
(COMPONENTS - этого нет на UML-диаграмме), которые могут быть
инициализированы из json-файла и по сути, выполняют за Creature всю
работу. 

Примечание: Player не является синглтоном, потому что этого не требуется - им
может управлять непосредственно класс игрового состояния.

3) Создание противников:
Непосредственно в GameState инициализируется уникальный указатель на объект
класса EnemySystem, который является системой управления противниками.

Здесь мы и пользуемся порождающим паттерном Prototype.
Изначально в векторе уникальных врагов создаётся по одному экземпляру
противника каждого вида и каждый получает в соответствие свой тип
(в соответствие с ячейкой вектора, в которой он лежит).

Затем, когда инициализируется монстрами вся игровая карта, мы можем
по набору чисел из конфигурационного json-файла (возможно сменим формат
для карты) вызвать метод Clone() у нужного противника из вектора
unique_enemies. Таким образом, мы создаём на карте монстров, ничего
не зная о их реализации и нам очень удобно изменять характеристики или
какие-то особенности каждого монстра.

Также выбор паттерна Prototype обоснован желанием создать особых противников,
которые умеют вызывать прислужников (EnemySpawner).
Каждый EnemySpawner при создании получает "внутрь" прототипа, который
будет клонироваться при спауне монстров, удобнее метода для спауна
и не придумаешь.

4) Карта: таким же образом создаётся карта - в векторе создаётся по 
экземпляру уникальной плитки, а затем при создании карты вызывается
метод Clone() у нужной плитки из вектора.
Здесь планировалось использование шаблона Приспособленец, но он
оказался несовместим с графической библиотекой.

5) Непосредственно создание монстров происходит с использованием
метода, немного похожего на FactoryMethod - по типу врага EnemySystem
понимает, какой экземпляр клонировать и выставлять на карту.

Подробнее в коде)

------------------------------------------------------

Вторая часть задания:

В этой части было необходимо заполнить игровой мир монстрами и добавить 
возможность координировать крупные группы врагов. Но в нашем проекте нет
необходимости в координации крупных групп врагов (подробнее далее),
но мы добавили небольшой класс EnemyGroup, на основе которого (а также
EnemyState - наследников класса State (или CreatureState)), будет
реализована боевая система в игре.

Мы произвели крупный рефакторинг кода - если раньше игровая карта,
EnemySystem, отвечающая за создание и обновление врагов, лежали в
GameState - непосредственно в игре, то теперь они лежат в своеобразных
"комнатах" (class Room). Достигнута существенная экономия ресурсов - 
теперь отрисовывать и обновлять ивенты/боёвку нужно только в текущей комнате.

Из текущих краеугольных камней реализации - создание статических переменных в 
классах вроде GameState(причём довольно мусорных), чтобы при загрузке
преобразовывать строчки в идентификаторы объектов (например - строчное название
комнаты в идентификатор комнаты ROOM_ID). Также стоит отметить появленние кучи
переменных вида: std::shared_ptr<std::unordered_map<ObjType, std::shared/unique_ptr<Object>>
для уникальных объектов вроде уникальных врагов или уникальных плиток на карте
(все ещё пользуемся шаблоном Прототип). 
В ближайшее время будет добавлен новый класс Database, который будет являться синглтоном,
в то же время давать глобальный доступ к переменным вида - переведи строчку в enum class.

Такое решение кажется обоснованным.

Теперь к изменениям:
1) Использован паттерн Composite для системы атрибутов в игре. 
В игре реализованы два типа атрибутов - базовые атрибуты и зависимые атрибуты, а также
есть хитрый атрибут(AttributeValue) - который является адаптированной (своего рода Adapter)
класса Attribute.

Итак:
	BaseAttribute - базовый атрибут, не зависящий ни от чего, содержит в себе набор RawBonus и Effect
(которые на самом деле наследники BaseAttribute и лежат внутри него в виде указателей на
BaseAttribute).
	RawBonus - "грубый" бонус - бонус, который присоединяется к дереву атрибутов персонажа
снаружи, допустим при приобретении какой-либо одежды. Когда одежда (ещё пока не реализованная, правда)
снимается, она устанавливает bool to_remove_ внутри своих эффектов как true, поэтому
система атрибутов поймёт, что бонус необходимо удалить.
	Effect - общий интерфейс для всех эффектов.
	TimedEffect - эффект, у которого есть время действия, удаляется по окончании этого времени.
	OverTimeEffect - эффект, который действует определенной время и изменяет свои параметры также
в определенное время (например, так можно реализовать эффект, изменяющийся со временем)
	ProckingEffect - OverTimeEffect, который возвращает IsReady() == true (готов к применению)
только когда проходит время тика. То есть это способ реализовать отравление персонажа - снимать
его текущее здоровье каждую секунду
	OperatingEffect - прямой наследник Effect, применяется всего один раз и потом исчезает.
	Пример: нанесение прямого урона персонажу.

В будущем планируется добавить в Effect специальные функции, которые будут для конкретных типов
эффектов принимать std::vector<BaseAttribute>, лежащий в AttributeComponent, и на этой основе
будут считать свои характеристики перед тем, как наложиться на врага(себя, группу врагов и т.д.)

Далее предстают такие классы:

Attribute - класс зависимого атрибута. Самое сложное во всём этом было добиться того, чтобы
не писать отдельного класса для каждого типа атрибута (т.к. таких классов пришлось бы написать
минимум 7 штук, а это необоснованно). Поэтому класс Attribute хранит внутри себя указатель на функцию
(std::function), которая определяется по AttributeID при непосредственно создании атрибута.

НО! Тут мы столкнулись с ужасной проблемой - атрибуты бывают разных типов. Например, урон персонажа имеет
по сути два значения - базовое и текущее(которое является непосредственно значением урона в конкретный момент).
А здоровье и мана - это атрибуты, которые вдобавок имеют ещё и максимальное значение.
Причём от базовых атрибутов зависят именно максимальные значения.

Решение проблемы - ввести адаптер AttributeValue, который хранит внутри себя указатель на атрибут-максимальное
значение и в то же время реализует стандартный интерфейс BaseAttribute. Также он хранит текущее относительное
значение параметра (от 0 до 1). Почему относительное? Пример: у персонажа 1000 здоровья, на него накладывается
эффект на +20% макс.здоровья - что должно произойти - у него останется 1000 здоровья из 1200 или будет 1200?
Решили, что 1200. Или вот - персонажу нанесут 1000 урона, а потом эффект спадёт - он же не должен умереть
от того, что после спадения эффекта здоровье упадёт с 200 до 0.


На основе AttributeComponent планируется написание SkillComponent, которая будет содержать способности персонажей.
Здесь точно уже будет реализована глобальная база данных, т.к. нужно же где-то хранить функции/unordered_map<> и т.д.,
чтобы получать все эти значения.


Теперь про монстров. Для них пока создан class EnemyGroup, который увы, нельзя назвать принадлежащим
к какому-то типу паттернов, это просто группа монстров, которая ведёт себя как один + оказывает
помощь друг другу по необходимости (для этого придётся реализовать void Help(td::unique_ptr<Enemy>& other)),
а в Update() группы вызывать этот самый Help от разных монстров.

Проблема координации врагов в том, что им точно нужен State - а это скорее тема третьей части.

2) Т.к. теперь у нас есть разные комнаты, мы написали класс Exit - позволяющие перемещаться между
комнатами - теперь намного проще создавать игровой мир. В текущей версии игры - красная дверь в первой комнате.


------------------------------------------------------------
3 часть:

Реализованы паттерны State (поведение врагов) и Command(пользовательский ввод).
State реализован для обычных врагов: IdleState - покой, PursuingState - преследование,
FightingState - бой. Переход между состояниями организован через возвращаемое значение
Update-метода (возвращает идентификатор State, в который нужно перейти).

Реализована простая система способностей, которая пока только хранит непосредственно эффекты, которые нужно наложить, да анимацию, которую нужно проиграть и по сути всё (нельзя сделать какой-то огненный шар).

Реализован обмен сообщениями между игроком и EnemySystem - так туда подаётся указатель на использованную способность. Я считаю, что такой обмен сообщениями мог бы стать основой для чего-то большего (прокающих ивентов, например).

Настроено проигрывание анимаций у игрока.

Из явных недостатков в плане контента - нет отработанного прогресса по уровням, анимаций и спрайтов врагов, интерфейса для текущего противника (чтобы можно было смотреть, сколько осталось здоровье у врага, которому сейчас наносится урон - очень полезная фича).





	